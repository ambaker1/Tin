\documentclass{article}

% Input packages & formatting
\input{template/packages}
\input{template/formatting}
\input{template/version}
\renewcommand{\cleartooddpage}[1][]{\ignorespaces} % single side
\newcommand{\caret}{$^\wedge$}

\title{\Huge Tin: A Tcl Package Manager\\\small Version \version}
\author{Alex Baker\\\small\url{https://github.com/ambaker1/Tin}}
\date{\small\today}
\begin{document}
\maketitle
\clearpage
\section{The Tin Database}
The Tin package provides a package database for installing and upgrading packages directly from GitHub. 
The ``tinlist.tcl'' file in the Tin installation initializes the Tin database, which can modified in the current session with the commands \cmdlink{tin add} and \cmdlink{tin remove}.

\begin{syntax}
\command{tin add} \$name \$version \$repo \$tag \$file
\end{syntax}
\begin{args}
\$name & Package name. \\
\$version & Package version. \\
\$repo & Github repository URL. \\
\$tag & Github release tag for version.  \\
\$file & Installer file path in repo. 
\end{args}

\begin{syntax}
\command{tin remove} \$name <\$version> <\$repo>
\end{syntax}
\begin{args}
\$name & Package name. \\
\$version & Package version to remove (optional, default all versions). \\
\$repo & Repository to remove (optional, default all repositories).
\end{args}

\begin{example}{Adding a package to the Tin database}
\begin{lstlisting}
package require tin
tin add foo 1.0 https://github.com/username/foo v1.0 install_foo.tcl
\end{lstlisting}
\end{example}
\clearpage
\subsection{Auto Packages}
The commands \cmdlink{tin add} and \cmdlink{tin remove} also have alternative syntax for adding and removing Auto-Tin packages.
An Auto-Tin package is one which has a GitHub repository that has release tags corresponding directly with the package versions, such as "v1.2.3". 
To be specific, version release tags must match the following regular expression:
\begin{lstlisting}[language=verbatim]
^v(0|[1-9]\d*)(\.(0|[1-9]\d*))*([ab](0|[1-9]\d*)(\.(0|[1-9]\d*))*)?$
\end{lstlisting}

\begin{syntax}
tin add -auto \$name \$repo \$file <{}<-exact> \$version> <\$reqs ...>
\end{syntax}
\begin{args}
\$name & Package name. \\
\$repo & Github repository URL. \\
\$file & Installer file path in repo. \\
-exact & Option to install exact version. \\
\$version & Package version. \\
\$reqs ... & Package version requirements, mutually exclusive with -exact option. 
\end{args}

\begin{syntax}
tin remove -auto \$name <\$repo> <\$file>
\end{syntax}
\begin{args}
\$name & Package name. \\
\$repo & Repository to remove (optional, default all repositories). \\
\$file & Installer file path to remove (optional, default all installer files).
\end{args}

Then, if a package is configured as an Auto-Tin package, the Tin database can be populated with versions available for installation with the command \cmdlink{tin fetch}.

\begin{syntax}
\command{tin fetch} <\$name>
\end{syntax}
\begin{args}
\$name & Package name (optional, default ``-all'' fetches for all Auto-Tin packages).
\end{args}

\clearpage
\subsection{Saving, Clearing, and Resetting the Tin Database}
The state of the Tin and Auto-Tin databases can be saved for future sessions with \cmdlink{tin save}, cleared with \cmdlink{tin clear}, and reset to default or factory settings with \cmdlink{tin reset}. 
Note that \cmdlink{tin save} does not modify the ``tinlist.tcl'' file in the installation of Tin, rather it saves to a hidden user-config file located in the user's home directory.
\begin{syntax}
\command{tin save}
\end{syntax}
\begin{syntax}
\command{tin clear}
\end{syntax}
\begin{syntax}
\command{tin reset} <-hard>
\end{syntax}
\begin{args}
-hard & Option to reset to factory settings.
\end{args}

\begin{example}{Saving changes to the Tin Database}
\begin{lstlisting}
tin reset -hard
tin add foo 1.0 https://github.com/username/foo v1.0 install_foo.tcl
tin save
\end{lstlisting}
\tcblower

\textit{"$\sim$/.tinlist.tcl" :}
\begin{lstlisting}
tin add foo 1.0 https://github.com/username/foo v1.0 install_foo.tcl
\end{lstlisting}
\end{example}

\clearpage
\section{Accessing the Tin Database}

The command \cmdlink{tin get} queries basic information about Tin, and returns blank if the requested entry does exist. 
Similar to \cmdlink{tin add} and \cmdlink{tin remove}, it has two forms, one for querying the main Tin database and one for querying the Auto-Tin database. 
Returns a dictionary associated with the supplied arguments.
\begin{syntax}
\command{tin get} \$name <\$version> <\$repo> \\
tin get -auto \$name <\$repo> <\$file>
\end{syntax}
\begin{args}
\$name & Package name. \\
\$version & Package version.  \\
\$repo & Github repository URL. \\
-auto & Option to query Auto-Tin database. \\
\$file & Installer file path in repo. \\
\end{args}

Additionally, the available packages in the Tin and Auto-Tin databases can be queried with the command \cmdlink{tin packages}, and the available versions for each package in the Tin database can be queried with the command \cmdlink{tin versions}.

\begin{syntax}
\command{tin packages} <-auto> <\$pattern>
\end{syntax}
\begin{args}
-auto & Option to search the Auto-Tin database. By default searches the Tin database only. \\
\$pattern & Optional ``glob'' pattern, default ``\texttt{*}'', or all packages.
\end{args}

\begin{syntax}
\command{tin versions} \$name <{}<-exact> \$version> <\$reqs ...>
\end{syntax}
\begin{args}
\$name & Package name. \\
-exact & Option to specify exact version. \\
\$version & Package version. \\
\$reqs ... & Package version requirements, mutually exclusive with -exact option.
\end{args}

\clearpage
\section{Installing, Uninstalling, and Upgrading Packages}
The command \cmdlink{tin install} installs packages directly from GitHub, and returns the version installed.
The command \cmdlink{tin depend} installs packages only if they are not installed, and returns the version number installed (useful for installation scripts).
The command \cmdlink{tin installed} returns the package version that is installed and meets the version requirements, or blank if it is not installed.
The command \cmdlink{tin uninstall} uninstalls packages, as long as they are available in the Tin or Auto-Tin database for installation, and returns blank if successful.
The command \cmdlink{tin upgrade} upgrades a package within the major version (for minor and patch upgrades) and returns the version number installed.
\begin{syntax}
\command{tin install} \$name <{}<-exact> \$version> <\$reqs ...>
\end{syntax}
\begin{syntax}
\command{tin depend} \$name <{}<-exact> \$version> <\$reqs ...>
\end{syntax}
\begin{syntax}
\command{tin installed} \$name <{}<-exact> \$version> <\$reqs ...>
\end{syntax}
\begin{syntax}
\command{tin uninstall} \$name <{}<-exact> \$version> <\$reqs ...>
\end{syntax}
\begin{syntax}
\command{tin upgrade} \$name <{}<-exact> \$version> <\$reqs ...>
\end{syntax}
\begin{args}
\$name & Package name. \\
-exact & Option to specify exact version. \\
\$version & Package version. \\
\$reqs ... & Package version requirements, mutually exclusive with -exact option.
\end{args}

To use a new version of a package without restarting your interpreter, you can use \cmdlink{tin forget} and \textit{package require} to reload the package.

\begin{syntax}
\command{tin forget} \$name
\end{syntax}
\begin{args}
\$name & Package name.
\end{args}

\begin{example}{Upgrading Tin, and reloading within current interpreter}
\begin{lstlisting}
package require tin
tin fetch tin
tin upgrade tin
tin forget tin
package require tin
\end{lstlisting}
\end{example}


\clearpage
\section{Loading and Importing Packages}
Tin also provides advanced tools for loading and importing packages.
The command \cmdlink{tin require} is similar to the Tcl command \textit{package require}, but with the added feature that if the package is missing, it will try to install it with \cmdlink{tin install}.
The command \cmdlink{tin import} additionally handles most use-cases of \textit{namespace import}. 
Both \cmdlink{tin require} and \cmdlink{tin import} return the version number of the package imported.
\begin{syntax}
\command{tin require} \$name <{}<-exact> \$version> <\$reqs ...>
\end{syntax}
\begin{args}
\$name & Package name. \\
-exact & Option to install exact version. \\
\$version & Package version. \\
\$reqs ... & Package version requirements, mutually exclusive with -exact option.
\end{args}
\begin{syntax}
\command{tin import} <-force> <\$patterns from> \$name <{}<-exact> \$version> <\$reqs ...> <as \$ns>
\end{syntax}
\begin{args}
-force & Option to overwrite existing commands. \\
\$patterns & Commands to import, or ``glob'' patterns, default ``\texttt{*}'', or all commands. \\
\$name & Package name. \\
-exact & Option to install exact version. \\
\$version & Package version. \\
\$reqs ... & Package version requirements, mutually exclusive with -exact option. \\
\$ns & Namespace to import into. Default global namespace, or ``\texttt{::}''.
\end{args}

\begin{example}{Importing all commands package ``foo''}
\begin{lstlisting}
package require tin
tin import foo 1.0
\end{lstlisting}
\end{example}

\clearpage
\section{Utilities for Package Development}
In addition to commands for installing and loading packages, Tin provides a few commands intended to help in writing installation and build files for your packages.
\subsection{Creating Package Directories}
Tin also provides utilities to simplify writing installation files.
The command \cmdlink{tin mkdir} creates a library directory to install a package in, with a normalized naming convention that allows it to be uninstalled easily with \cmdlink{tin uninstall}. 
\begin{syntax}
\command{tin mkdir} <-force> <\$basedir> \$name \$version
\end{syntax}
\begin{args}
-force & Option to create fresh library directory (deletes existing folder). \\
\$basedir & Base directory, default one folder up from the Tcl library folder. \\
\$name & Package name. \\
\$version & Package version.
\end{args}

See the example installation file for a package ``foo'' that requires the package ``bar 1.2'', and installs in library folder ``foo-1.0''.
\begin{example}{Example file ``install\textunderscore{}foo.tcl''}
\begin{lstlisting}
package require tin
tin depend bar 1.2
set dir [tin mkdir -force foo 1.0]
file copy README.md $dir
file copy LICENSE $dir
file copy lib/bar.tcl $dir
file copy lib/pkgIndex.pdf $dir
\end{lstlisting}
\end{example}

\clearpage
\subsection{Building Library Files from Source with Configuration Variable Substitution}
The command \cmdlink{tin bake} takes an input text file, and writes an output text file after substitution of configuration variables such as \texttt{@VERSION@}.
This is especially helpful for ensuring that the package version is consistent across the entire project.

\begin{syntax}
\command{tin bake} \$inFile \$outFile \$config
\end{syntax}
\begin{args}
\$inFile & Source file to read from. \\
\$outFile & File to write to after substitution. \\
\$config & Dictionary of config variable names and values. Config variables must be uppercase alphanumeric.
\end{args}

See below for an example of how \cmdlink{tin bake} can be used to automatically update a ``pkgIndex.tcl'' file:

\begin{example}{Building a ``pkgIndex.tcl'' file}
\begin{lstlisting}
package require tin
tin bake pkgIndex.tin pkgIndex.tcl {VERSION 1.0}
\end{lstlisting}
\tcblower

\textit{"pkgIndex.tin" :}
\begin{lstlisting}
package ifneeded foo @VERSION@ [list source [file join $dir foo.tcl]]
\end{lstlisting}
\textit{"pkgIndex.tcl" :}
\begin{lstlisting}
package ifneeded foo 1.0 [list source [file join $dir foo.tcl]]
\end{lstlisting}
\end{example}
\end{document}


