\documentclass{article}

% Input packages & formatting
\input{template/packages}
\input{template/formatting}
\input{template/version}
\renewcommand{\cleartooddpage}[1][]{\ignorespaces} % single side
\newcommand{\caret}{$^\wedge$}

\title{\Huge Tin: A Tcl Package Manager\\\small Version \version}
\author{Alex Baker\\\small\url{https://github.com/ambaker1/Tin}}
\date{\small\today}
\begin{document}
\maketitle
\begin{abstract}
Tin is a package installer for Tcl. 
With Tin, you can easily install Tcl packages directly from GitHub.
\end{abstract}
\clearpage
\section{The Tin List}
Tin installs packages that are in the ``Tin List'', which can be modified in the current session with the commands \cmdlink{tin add} and \cmdlink{tin remove}.
\begin{syntax}
\command{tin add} \$name \$version \$repo \$tag \$file
\end{syntax}
\begin{args}
\$name & Package name. \\
\$version & Package version. \\
\$repo & Github repository URL. \\
\$tag & Github release tag for version.  \\
\$file & Installer file path in repo. 
\end{args}

\begin{syntax}
\command{tin remove} \$name <\$version> <\$repo>
\end{syntax}
\begin{args}
\$name & Package name. \\
\$version & Package version to remove (optional, default all versions). \\
\$repo & Repository to remove (optional, default all repositories).
\end{args}

\begin{example}{Adding a package to the Tin List}
\begin{lstlisting}
package require tin
tin add foo 1.0 https://github.com/username/foo v1.0 install_foo.tcl
\end{lstlisting}
\end{example}
\clearpage
\subsection{Auto Packages}
The commands \cmdlink{tin add} and \cmdlink{tin remove} also have alternative syntax for adding and removing Auto-Tin packages.
An Auto-Tin package is one which has a GitHub repository that has release tags corresponding directly with the package versions, such as ``v1.2.3''. 
To be specific, version release tags must match the following regular expression:
\begin{lstlisting}[language=verbatim]
^v(0|[1-9]\d*)(\.(0|[1-9]\d*))*([ab](0|[1-9]\d*)(\.(0|[1-9]\d*))*)?$
\end{lstlisting}

\begin{syntax}
tin add -auto \$name \$repo \$file <{}<-exact> \$version> <\$reqs ...>
\end{syntax}
\begin{args}
\$name & Package name. \\
\$repo & Github repository URL. \\
\$file & Installer file path in repo. \\
-exact & Option to specify exact version. \\
\$version & Package version. \\
\$reqs ... & Package version requirements, mutually exclusive with -exact option. 
\end{args}

\begin{syntax}
tin remove -auto \$name <\$repo> <\$file>
\end{syntax}
\begin{args}
\$name & Package name. \\
\$repo & Repository to remove (optional, default all repositories). \\
\$file & Installer file path to remove (optional, default all installer files).
\end{args}

Then, if a package is configured as an Auto-Tin package, the Tin List can be populated with versions available for installation with the command \cmdlink{tin fetch}.

\begin{syntax}
\command{tin fetch} <\$name>
\end{syntax}
\begin{args}
\$name & Package name (optional, default ``-all'' fetches for all Auto-Tin packages).
\end{args}

\clearpage
\subsection{The Official Tin List}
The ``tinlist.tcl'' file in the Tin installation initializes the Tin List. \\
As of Tin version \version, these are the packages in the official Tin List:
\input{template/TinList.tex}
\clearpage
\subsection{Saving, Clearing, and Resetting the Tin List}
The state of the Tin List can be saved for future sessions with \cmdlink{tin save}, cleared with \cmdlink{tin clear}, and reset to default or factory settings with \cmdlink{tin reset}. 
Note that \cmdlink{tin save} does not modify the ``tinlist.tcl'' file in the Tin installation. 
Rather, it saves to a hidden user-config file located in the user's home directory.
\begin{syntax}
\command{tin save}
\end{syntax}
\begin{syntax}
\command{tin clear}
\end{syntax}
\begin{syntax}
\command{tin reset} <-hard>
\end{syntax}
\begin{args}
-hard & Option to reset to factory settings.
\end{args}

\begin{example}{Saving changes to the Tin List}
\begin{lstlisting}
tin reset -hard
tin add foo 1.0 https://github.com/username/foo v1.0 install_foo.tcl
tin save
\end{lstlisting}
\tcblower

\textit{"$\sim$/.tinlist.tcl" :}
\begin{lstlisting}
tin add foo 1.0 https://github.com/username/foo v1.0 install_foo.tcl
\end{lstlisting}
\end{example}

\clearpage
\subsection{Accessing the Tin List}

The command \cmdlink{tin get} queries basic information about Tin, and returns blank if the requested entry does exist. 
Similar to \cmdlink{tin add} and \cmdlink{tin remove}, it has two forms, one for querying Tin packages and one for querying Auto-Tin packages. 
Returns a dictionary associated with the supplied arguments.
\begin{syntax}
\command{tin get} \$name <\$version> <\$repo> \\
tin get -auto \$name <\$repo> <\$file>
\end{syntax}
\begin{args}
\$name & Package name. \\
\$version & Package version.  \\
\$repo & Github repository URL. \\
-auto & Option to query Auto-Tin packages. \\
\$file & Installer file path in repo. \\
\end{args}

Additionally, the available packages in the Tin List can be queried with the command \cmdlink{tin packages}, and the available versions for each Tin package can be queried with the command \cmdlink{tin versions}.

\begin{syntax}
\command{tin packages} <-auto> <\$pattern>
\end{syntax}
\begin{args}
-auto & Option to search for Auto-Tin packages. By default searches Tin packages only. \\
\$pattern & Optional ``glob'' pattern, default ``\texttt{*}'', or all packages.
\end{args}

\begin{syntax}
\command{tin versions} \$name <{}<-exact> \$version> <\$reqs ...>
\end{syntax}
\begin{args}
\$name & Package name. \\
-exact & Option to specify exact version. \\
\$version & Package version. \\
\$reqs ... & Package version requirements, mutually exclusive with -exact option.
\end{args}

\clearpage
\section{Package Utilities}
The command \cmdlink{tin installed} returns the package version number that would be loaded with \textit{package require}, or blank if the package is not installed. 
If there is no package version in the Tcl package database satisfying the requirements, it will call the \cmdlink{package unknown} script to load \textit{package ifneeded} statements from ``pkgIndex.tcl'' files, just like what \textit{package require} does, but without loading the package.
\begin{syntax}
\command{tin installed} \$name <{}<-exact> \$version> <\$reqs ...>
\end{syntax}
\begin{args}
\$name & Package name. \\
-exact & Option to specify exact version. \\
\$version & Package version. \\
\$reqs ... & Package version requirements, mutually exclusive with -exact option.
\end{args}
The command \cmdlink{tin forget} is short-hand for both \textit{package forget} and \textit{namespace delete}, but it will not throw an error if there is no namespace corresponding with the package name. 
\begin{syntax}
\command{tin forget} \$name ...
\end{syntax}
\begin{args}
\$name & Package name. 
\end{args}

\clearpage
\section{Installing and Upgrading Packages}
The command \cmdlink{tin install} installs packages directly from GitHub, and returns the version installed.

The command \cmdlink{tin depend} installs packages only if they are not installed, and returns the version number installed (useful for dependencies in installation scripts).

The command \cmdlink{tin upgrade} upgrades a package within the major version (for minor and patch upgrades) and returns the version number installed.
\begin{syntax}
\command{tin install} \$name <{}<-exact> \$version> <\$reqs ...>
\end{syntax}
\begin{syntax}
\command{tin depend} \$name <{}<-exact> \$version> <\$reqs ...>
\end{syntax}
\begin{syntax}
\command{tin upgrade} \$name <{}<-exact> \$version> <\$reqs ...>
\end{syntax}
\begin{args}
\$name & Package name. \\
-exact & Option to specify exact version. \\
\$version & Package version. \\
\$reqs ... & Package version requirements, mutually exclusive with -exact option.
\end{args}

\begin{example}{Upgrading Tin, and reloading within current interpreter}
\begin{lstlisting}
# Upgrade Tin
package require tin
tin upgrade tin
# Reload Tin
tin forget tin
package require tin
\end{lstlisting}
\end{example}

\clearpage
\section{Uninstalling Packages}
The command \cmdlink{tin uninstall} uninstalls packages (as long as they are in the Tin List), and returns blank if successful, or error if it was unsuccessful in uninstalling the package. 

By default, this command simply deletes the library folder associated with the package.
However, if a ``pkgUninstall.tcl'' file is located within the package folder, it will run that file instead, with the variable \texttt{\$dir} set to the package library folder path, similar to how ``pkgIndex.tcl'' files work.
\begin{syntax}
\command{tin uninstall} \$name <{}<-exact> \$version> <\$reqs ...>
\end{syntax}
\begin{args}
\$name & Package name. \\
-exact & Option to specify exact version. \\
\$version & Package version. \\
\$reqs ... & Package version requirements, mutually exclusive with -exact option.
\end{args}
\begin{example}{Complex uninstall file ``pkgUninstall.tcl''}
\begin{lstlisting}
set bindir [file dirname [info nameofexecutable]]
file delete [file join $bindir foo.bat]; # delete file in the bin directory
file delete -force $dir; # Clean up package
\end{lstlisting}
\end{example}

\clearpage
\section{Loading and Importing Packages}
The command \cmdlink{tin require} is similar to the Tcl command \textit{package require}, but with the added feature that if the package is missing, it will try to install it with \cmdlink{tin install}.

The command \cmdlink{tin import} additionally handles most use-cases of \textit{namespace import}. 
Both \cmdlink{tin require} and \cmdlink{tin import} return the version number of the package imported.
\begin{syntax}
\command{tin require} \$name <{}<-exact> \$version> <\$reqs ...>
\end{syntax}
\begin{args}
\$name & Package name. \\
-exact & Option to specify exact version. \\
\$version & Package version. \\
\$reqs ... & Package version requirements, mutually exclusive with -exact option.
\end{args}
\begin{syntax}
\command{tin import} <-force> <\$patterns from> \$name <{}<-exact> \$version> <\$reqs ...> <as \$ns>
\end{syntax}
\begin{args}
-force & Option to overwrite existing commands. \\
\$patterns & Commands to import, or ``glob'' patterns, default ``\texttt{*}'', or all commands. \\
\$name & Package name. \\
-exact & Option to specify exact version. \\
\$version & Package version. \\
\$reqs ... & Package version requirements, mutually exclusive with -exact option. \\
\$ns & Namespace to import into. Default global namespace, or ``\texttt{::}''.
\end{args}

\begin{example}{Importing all commands package ``foo''}
\begin{lstlisting}
package require tin
tin import foo 1.0
\end{lstlisting}
\end{example}

\clearpage
\section{Utilities for Package Development}
In addition to commands for installing and loading packages, Tin provides a few commands intended to help in writing installation and build files for your packages.
\subsection{Creating Package Directories}
The command \cmdlink{tin mkdir} creates a library directory to install a package in, with a normalized naming convention that allows it to be uninstalled easily with \cmdlink{tin uninstall}. 
\begin{syntax}
\command{tin mkdir} <-force> <\$basedir> \$name \$version
\end{syntax}
\begin{args}
-force & Option to create fresh library directory (deletes existing folder). \\
\$basedir & Base directory, default one folder up from the Tcl library folder. \\
\$name & Package name. \\
\$version & Package version.
\end{args}

See the example installation file for a package ``foo'' that requires the package ``bar 1.2'', and installs in library folder ``foo-1.0''.
\begin{example}{Example file ``install\textunderscore{}foo.tcl''}
\begin{lstlisting}
package require tin
tin depend bar 1.2
set dir [tin mkdir -force foo 1.0]
file copy README.md $dir
file copy LICENSE $dir
file copy lib/bar.tcl $dir
file copy lib/pkgIndex.pdf $dir
\end{lstlisting}
\end{example}

\clearpage
\subsection{Building Library Files from Source with Configuration Variable Substitution}
The command \cmdlink{tin bake} takes an input text file, and writes an output text file after substitution of configuration variables such as \texttt{@VERSION@}.
This is especially helpful for ensuring that the package version is consistent across the entire project.
If a source directory is used as input, it will batch bake all ``.tin'' files. 

\begin{syntax}
\command{tin bake} \$src \$target \$config \\
tin bake \$src \$target \$varName \$value ...
\end{syntax}
\begin{args}
\$src & Source file, or directory with ``.tin'' files. \\
\$target & Target file, or directory to write ``.tcl'' files to. \\
\$config & Dictionary of config variable names and values. Config variables must be uppercase alphanumeric. \\
\$varName \$value ... & Config variable names and values. Mutually exclusive with \texttt{\$config}.
\end{args}

See below for an example of how \cmdlink{tin bake} can be used to automatically update a ``pkgIndex.tcl'' file:

\begin{example}{Building a ``pkgIndex.tcl'' file}
\begin{lstlisting}
package require tin
tin bake pkgIndex.tin pkgIndex.tcl {VERSION 1.0}
\end{lstlisting}
\tcblower

\textit{"pkgIndex.tin" :}
\begin{lstlisting}
package ifneeded foo @VERSION@ [list source [file join $dir foo.tcl]]
\end{lstlisting}
\textit{"pkgIndex.tcl" :}
\begin{lstlisting}
package ifneeded foo 1.0 [list source [file join $dir foo.tcl]]
\end{lstlisting}
\end{example}
\end{document}



